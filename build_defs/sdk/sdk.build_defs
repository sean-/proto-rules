def proto_build_defs(name:str, srcs:str|list, proto_languages:dict, visibility=["PUBLIC"]):
    """Exposes `.build_defs` containing `proto_language()` rules

    name (str): The name of this rule
    src (str|list): The .build_defs files containing the definition
    proto_languages (dict): A map of proto language types to functions that return the `proto_language()` below.
                            e.g. `{"grpc_language": ["go_grpc_language"], "proto_language": ["go_proto_language"]}`
                            where `go_grpc_language` is a function that has a `return proto_language(...)`
    """
    labels = []
    for type, langs in proto_languages.items():
        labels += [f"{type}:{lang}" for lang in langs]
    return filegroup(
       name = name,
       srcs = srcs,
       visibility = visibility,
       labels = labels,
   )

def proto_language(language:str, build_def:function, additional_provides:list|dict=[]):
    """Returns the definition of how to build a particular language for proto_library or grpc_library.

    This should be wrapped in a function so that the proto_languages() build definition below can 
    
    Args:
      language (str): Name of the language (as we would name it).
      build_def (function): The build definition lambda. Will be called with the same arguments proto_library
                            was called with, except with an additional `tag` parameter which is to be applied to the
                            final build rule. Should return
      additional_provides (list|dict): Any additional tags from the rule generated by func that should be provided by
                                       the final proto_library rule. The _{name}#{language} tag will already be provided.
                                       Can be a dictionary if the provide key on the `proto_library` should differ from
                                       the language rule. In which case, the key will be the key on the proto_library,
                                       and the value will be the tag to provide from build_def.
    """
    return {
        'language': language,
        'build_def': build_def,
        'additional_provides': additional_provides,
    }

def _get_languages_prebuild(label_prefix, includes):
    """
    Generates a pre_build function that updates the command of the target to output a .build_defs file. This file then
    exposes a function based on the name of the rule, e.g. `proto_languages()`, which return the proto languages map.

    This can then be subincluded by your custom proto build definition type. For an exmaple, there are built in
    definitions, `proto_library()`, and `grpc_library()` that subcinclude `//build_def:proto_langauges` and
    `//build_def:grpc_langauges`
    """
    def pre_build(name):
        subincludes = ", ".join([f"\\\"{i}\\\"" for i in includes])
        language_defs = ", ".join(get_labels(name, label_prefix))
        build_def = [
            f"echo \"subinclude({subincludes})\" >> $OUT" if subincludes else "echo",
            f"echo \"def {name}():\" >> $OUT",
            f"echo \"    langs = [l() for l in [{language_defs}]]\" >> $OUT",
             "echo \"    return {l.language: l for l in langs}\" >> $OUT",
        ]
        set_command(name, " && ".join(build_def))

    return pre_build

def protoc_plugins(name:str, build_defs: list, type:str, visibility=["PUBLIC"]):
    """Used to collect a set of language definitions of a given type into a dictionary. The key of this dict is the
    language key, e.g. "go", and the value is the dict returned from `proto_language()`. This target should be
    subincluded by other build definitions to exposes a function which returns this map. This function will be named
    after this build rule, for example:

    ```
    protoc_plugins(
        name = "proto_languages",
        build_defs = CONFIG.PROTO.DEFINITIONS,
        type = "proto_language",
    )
    ```

    Can then be subincluded
    ```
    subcinclude(":proto_languages")

    proto_library(
        name = "name",
        srcs = ["something.proto"],
        # proto_languages() here matches the name fo the protoc_plugins() rule above
        languages = proto_language(),
    )
    ```

    name (str): The name of the rule
    build_defs (list): Build rules outputting the .build_defs files that contain the proto_language() definitions.
    type (str): The type of languages to collect. This should match the keys on the `proto_languages` dictionary
                passed to `proto_build_defs()`.
    """
    return build_rule(
        name = name,
        outs = [f"{name}.build_defs"],
        pre_build = _get_languages_prebuild(type + ":", build_defs),
        deps = build_defs,
        visibility = visibility,
    )

def _collect_protoc_flags(prebuild):
    """Defines a pre-build function that updates a build command with transitive protoc flags."""
    def ret(name):
        labels = get_labels(name, 'protoc:')
        if labels:
            cmd = get_command(name)
            set_command(name, cmd.replace('$TOOLS_PROTOC ', '$TOOLS_PROTOC %s ' % ' '.join(labels)))
        if prebuild:
            prebuild(name)
    return ret

def protoc_rule(name:str, srcs:list, deps:list, language:str, tools:dict={}, protoc_flags:list, plugin_flags:list, root_dir:str,
                pre_build:function=None, labels:list, test_only:bool, visibility:list):

    tools["protoc"] = [CONFIG.PROTO.PROTOC_TOOL]

    flags = [' '.join(protoc_flags + plugin_flags)] + CONFIG.PROTO.PROTOC_FLAGS

    out_dir = "out_dir"
    language_out_dir = language

    cmd = f'$TOOLS_PROTOC -I. ' + ' '.join(flags)
    if root_dir:
        escaped_root_dir = root_dir.replace("/", "\/")
        cmd = f'cd {root_dir}; {cmd} ${{SRCS//{escaped_root_dir}\\//}} && cd "$TMP_DIR"'
    else:
        cmd += ' ${SRCS}'

    cmd = f'(export OUT_DIR=$TMP_DIR/{language_out_dir} && {cmd})'

    pkg_dir = package_name().removeprefix(root_dir).removeprefix("/")

    cmd += f' && (mv -f {language_out_dir}/{pkg_dir}/* {out_dir}; true) && (mv -f {language_out_dir}/* {out_dir}; true)'

    cmd = f'mkdir out_dir && mkdir {language_out_dir} && {cmd}'

    log.info(f'srcs {srcs}')

    # protoc_flags are applied transitively to dependent rules via labels.
    labels += ['protoc:' + flag for flag in protoc_flags] + ["codegen"]
    return build_rule(
        name = name,
        tag = f'protoc_{language}',
        srcs = srcs,
        output_dirs = [f'{out_dir}/**'],
        cmd = cmd,
        deps = deps,
        tools = tools,
        requires = ['proto', language],
        pre_build = _collect_protoc_flags(pre_build),
        labels = labels,
        needs_transitive_deps = True,
        test_only = test_only,
        visibility = visibility,
    )

def filter_srcs(name, srcs, extension):
    """Filters re-exports its srcs filtering on the provided extension"""
    return build_rule(
        name = name,
        srcs = srcs,
        cmd = '\n'.join([
            'mkdir _out && for i in $SRCS; do ',
            f'   if [[ "$i" == *.{extension} ]]; then ',
            '        mkdir -p _out/$(dirname $i) ',
            '        mv $i _out/$i ',
            '     fi ',
            'done ']),
        output_dirs = ["_out/**"],
    )
